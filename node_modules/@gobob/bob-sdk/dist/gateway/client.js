"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GatewayApiClient = exports.TESTNET_GATEWAY_BASE_URL = exports.MAINNET_GATEWAY_BASE_URL = void 0;
const ethers_1 = require("ethers");
const types_1 = require("./types");
const tokens_1 = require("./tokens");
const wallet_1 = require("../wallet");
const bitcoin_address_validation_1 = require("bitcoin-address-validation");
const esplora_1 = require("../esplora");
exports.MAINNET_GATEWAY_BASE_URL = 'https://gateway-api-mainnet.gobob.xyz';
exports.TESTNET_GATEWAY_BASE_URL = 'https://gateway-api-testnet.gobob.xyz';
class GatewayApiClient {
    constructor(chainName) {
        switch (chainName) {
            case 'mainnet':
            case types_1.Chain.BOB:
                this.chain = types_1.Chain.BOB;
                this.baseUrl = exports.MAINNET_GATEWAY_BASE_URL;
                break;
            case 'testnet':
            case types_1.Chain.BOB_SEPOLIA:
                this.chain = types_1.Chain.BOB_SEPOLIA;
                this.baseUrl = exports.TESTNET_GATEWAY_BASE_URL;
                break;
            default:
                throw new Error('Invalid chain');
        }
    }
    get chainId() {
        return this.chain === types_1.Chain.BOB ? types_1.ChainId.BOB : types_1.ChainId.BOB_SEPOLIA;
    }
    getChains() {
        return Object.values(types_1.Chain);
    }
    async getQuote(params) {
        const isMainnet = params.toChain === types_1.ChainId.BOB ||
            (typeof params.toChain === 'string' && params.toChain.toLowerCase() === types_1.Chain.BOB);
        const isTestnet = params.toChain === types_1.ChainId.BOB_SEPOLIA ||
            (typeof params.toChain === 'string' && params.toChain.toLowerCase() === types_1.Chain.BOB_SEPOLIA);
        const isInvalidNetwork = !isMainnet && !isTestnet;
        const isMismatchMainnet = isMainnet && this.chain !== types_1.Chain.BOB;
        const isMismatchTestnet = isTestnet && this.chain !== types_1.Chain.BOB_SEPOLIA;
        if (isInvalidNetwork || isMismatchMainnet || isMismatchTestnet) {
            throw new Error('Invalid output chain');
        }
        let outputTokenAddress = '';
        let strategyAddress;
        const toToken = params.toToken.toLowerCase();
        if (params.strategyAddress?.startsWith('0x')) {
            strategyAddress = params.strategyAddress;
        }
        const chainId = this.chainId;
        if (toToken.startsWith('0x')) {
            outputTokenAddress = toToken;
        }
        else if (isMainnet && tokens_1.SYMBOL_LOOKUP[chainId][toToken]) {
            outputTokenAddress = tokens_1.SYMBOL_LOOKUP[chainId][toToken].address;
        }
        else if (isTestnet && tokens_1.SYMBOL_LOOKUP[chainId][toToken]) {
            outputTokenAddress = tokens_1.SYMBOL_LOOKUP[chainId][toToken].address;
        }
        else {
            throw new Error('Unknown output token');
        }
        const url = new URL(`${this.baseUrl}/quote/${outputTokenAddress}`);
        if (strategyAddress) {
            url.searchParams.append('strategy', `${strategyAddress}`);
        }
        const atomicAmount = params.amount;
        if (atomicAmount) {
            url.searchParams.append('satoshis', `${atomicAmount}`);
        }
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
            },
        });
        const quote = await response.json();
        return {
            ...quote,
            fee: quote.fee + (params.gasRefill || 0),
            baseToken: tokens_1.ADDRESS_LOOKUP[chainId][quote.baseTokenAddress],
            outputToken: quote.strategyAddress ? tokens_1.ADDRESS_LOOKUP[chainId][outputTokenAddress] : undefined,
        };
    }
    async startOrder(gatewayQuote, params) {
        if (!params.toUserAddress.startsWith('0x') || !ethers_1.ethers.isAddress(params.toUserAddress)) {
            throw new Error('Invalid user address');
        }
        const abiCoder = new ethers_1.AbiCoder();
        const request = {
            gatewayAddress: gatewayQuote.gatewayAddress,
            strategyAddress: gatewayQuote.strategyAddress,
            satsToConvertToEth: params.gasRefill || 0,
            userAddress: params.toUserAddress,
            gatewayExtraData: undefined,
            strategyExtraData: abiCoder.encode(['uint256'], [0]),
            satoshis: gatewayQuote.satoshis,
        };
        const response = await fetch(`${this.baseUrl}/order`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
            },
            body: JSON.stringify(request),
        });
        if (!response.ok) {
            throw new Error('Failed to create order');
        }
        const data = await response.json();
        if (data.opReturnHash != calculateOpReturnHash(request)) {
            throw new Error('Invalid OP_RETURN hash');
        }
        let psbtBase64;
        if (params.fromUserAddress &&
            typeof params.fromChain === 'string' &&
            params.fromChain.toLowerCase() === types_1.Chain.BITCOIN) {
            psbtBase64 = await (0, wallet_1.createBitcoinPsbt)(params.fromUserAddress, gatewayQuote.bitcoinAddress, gatewayQuote.satoshis, params.fromUserPublicKey, data.opReturnHash, params.feeRate, gatewayQuote.txProofDifficultyFactor);
        }
        return {
            uuid: data.uuid,
            opReturnHash: data.opReturnHash,
            bitcoinAddress: gatewayQuote.bitcoinAddress,
            satoshis: gatewayQuote.satoshis,
            psbtBase64,
        };
    }
    async finalizeOrder(uuid, bitcoinTxOrId) {
        bitcoinTxOrId = stripHexPrefix(bitcoinTxOrId);
        let bitcoinTxHex;
        if (bitcoinTxOrId.length === 64) {
            const esploraClient = new esplora_1.EsploraClient(this.chain === types_1.Chain.BOB ? bitcoin_address_validation_1.Network.mainnet : bitcoin_address_validation_1.Network.testnet);
            bitcoinTxHex = await esploraClient.getTransactionHex(bitcoinTxOrId);
        }
        else {
            bitcoinTxHex = bitcoinTxOrId;
        }
        const response = await fetch(`${this.baseUrl}/order/${uuid}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
            },
            body: JSON.stringify({ bitcoinTx: bitcoinTxHex }),
        });
        if (!response.ok) {
            throw new Error('Failed to update order');
        }
        return await response.json();
    }
    async getOrders(userAddress) {
        const chainId = this.chainId;
        const response = await this.fetchGet(`${this.baseUrl}/orders/${userAddress}`);
        const orders = await response.json();
        return orders.map((order) => {
            function getFinal(base, output) {
                return order.status
                    ? order.strategyAddress
                        ? output
                            ? output
                            : base
                        : base
                    : order.strategyAddress
                        ? output
                        : base;
            }
            const getTokenAddress = () => {
                return getFinal(order.baseTokenAddress, order.outputTokenAddress);
            };
            const getToken = () => {
                return tokens_1.ADDRESS_LOOKUP[chainId][getTokenAddress()];
            };
            const getConfirmations = async (esploraClient, latestHeight) => {
                const txStatus = await esploraClient.getTransactionStatus(order.txid);
                if (!latestHeight) {
                    latestHeight = await esploraClient.getLatestHeight();
                }
                return txStatus.confirmed ? latestHeight - txStatus.block_height + 1 : 0;
            };
            return {
                gasRefill: order.satsToConvertToEth,
                ...order,
                baseToken: tokens_1.ADDRESS_LOOKUP[chainId][order.baseTokenAddress],
                outputToken: tokens_1.ADDRESS_LOOKUP[chainId][order.outputTokenAddress],
                getTokenAddress,
                getToken,
                getTokenAmount() {
                    let amount = order.satoshis - order.fee;
                    const token = getToken();
                    if (token && !order.outputTokenAmount) {
                        amount *= Math.pow(10, token.decimals - 8);
                    }
                    return getFinal(amount, order.outputTokenAmount);
                },
                getConfirmations,
                async getStatus(esploraClient, latestHeight) {
                    const confirmations = await getConfirmations(esploraClient, latestHeight);
                    const hasEnoughConfirmations = confirmations >= order.txProofDifficultyFactor;
                    const data = { confirmations };
                    return !hasEnoughConfirmations
                        ? { confirmed: false, data }
                        : order.status
                            ? order.strategyAddress
                                ? order.outputTokenAddress
                                    ? { success: true, data }
                                    : { success: false, data }
                                : { success: true, data }
                            : { pending: true, data };
                },
            };
        });
    }
    async getStrategies() {
        const response = await this.fetchGet(`${this.baseUrl}/strategies`);
        const chainName = this.chain.toString();
        const chainId = this.chainId;
        const strategies = await response.json();
        return strategies.map((strategy) => {
            const strategySlug = slugify(strategy.strategyName);
            const inputToken = tokens_1.ADDRESS_LOOKUP[chainId][strategy.inputTokenAddress];
            const outputToken = strategy.outputTokenAddress
                ? tokens_1.ADDRESS_LOOKUP[chainId][strategy.outputTokenAddress]
                : undefined;
            return {
                id: strategySlug,
                type: 'deposit',
                address: strategy.strategyAddress,
                method: '',
                chain: {
                    id: '',
                    chainId: chainId,
                    slug: chainName,
                    name: chainName,
                    logo: '',
                    type: 'evm',
                    singleChainSwap: true,
                    singleChainStaking: true,
                },
                integration: {
                    type: strategy.strategyType,
                    slug: strategySlug,
                    name: strategy.strategyName,
                    logo: strategy.projectLogo || outputToken?.logoURI || '',
                    monetization: false,
                },
                inputToken: {
                    symbol: inputToken.symbol,
                    address: inputToken.address,
                    logo: inputToken.logoURI,
                    decimals: inputToken.decimals,
                    chain: chainName,
                },
                outputToken: outputToken
                    ? {
                        symbol: outputToken.symbol,
                        address: outputToken.address,
                        logo: outputToken.logoURI,
                        decimals: outputToken.decimals,
                        chain: chainName,
                    }
                    : null,
            };
        });
    }
    async getTokenAddresses(includeStrategies = true) {
        const response = await this.fetchGet(`${this.baseUrl}/tokens?includeStrategies=${includeStrategies}`);
        return response.json();
    }
    async getTokens(includeStrategies = true) {
        const tokens = await this.getTokenAddresses(includeStrategies);
        return tokens.map((token) => tokens_1.ADDRESS_LOOKUP[this.chainId][token]).filter((token) => token !== undefined);
    }
    async fetchGet(url) {
        return await fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
            },
        });
    }
}
exports.GatewayApiClient = GatewayApiClient;
function calculateOpReturnHash(req) {
    const abiCoder = new ethers_1.AbiCoder();
    return ethers_1.ethers.keccak256(abiCoder.encode(['address', 'address', 'uint256', 'address', 'bytes', 'bytes'], [
        req.gatewayAddress,
        req.strategyAddress || ethers_1.ethers.ZeroAddress,
        req.satsToConvertToEth,
        req.userAddress,
        req.gatewayExtraData || '0x',
        req.strategyExtraData || '0x',
    ]));
}
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
function stripHexPrefix(str) {
    return isHexPrefixed(str) ? str.slice(2) : str;
}
function slugify(str) {
    return str
        .toLowerCase()
        .replace(/ /g, '-')
        .replace(/[^\w-]+/g, '');
}
//# sourceMappingURL=client.js.map