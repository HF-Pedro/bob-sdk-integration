"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EsploraClient = exports.REGTEST_ESPLORA_BASE_PATH = exports.TESTNET_ESPLORA_BASE_PATH = exports.MAINNET_ESPLORA_BASE_PATH = void 0;
exports.MAINNET_ESPLORA_BASE_PATH = 'https://btc-mainnet.gobob.xyz';
exports.TESTNET_ESPLORA_BASE_PATH = 'https://btc-testnet.gobob.xyz';
exports.REGTEST_ESPLORA_BASE_PATH = 'http://localhost:3003';
function encodeEsploraMerkleProof(merkle) {
    return merkle.map((item) => Buffer.from(item, 'hex').reverse().toString('hex')).join('');
}
class EsploraClient {
    constructor(networkOrUrl = 'mainnet') {
        switch (networkOrUrl) {
            case 'mainnet':
                this.basePath = exports.MAINNET_ESPLORA_BASE_PATH;
                break;
            case 'testnet':
                this.basePath = exports.TESTNET_ESPLORA_BASE_PATH;
                break;
            case 'regtest':
                this.basePath = exports.REGTEST_ESPLORA_BASE_PATH;
                break;
            default:
                this.basePath = networkOrUrl;
        }
    }
    async getLatestHeight() {
        return parseInt(await this.getText(`${this.basePath}/blocks/tip/height`), 10);
    }
    async getBlock(blockHash) {
        return this.getJson(`${this.basePath}/block/${blockHash}`);
    }
    async getBlockHash(height) {
        return this.getText(`${this.basePath}/block-height/${height}`);
    }
    async getBlockHeader(hash) {
        return this.getText(`${this.basePath}/block/${hash}/header`);
    }
    async getBlockHeaderAt(height) {
        const blockHash = await this.getBlockHash(height);
        return await this.getBlockHeader(blockHash);
    }
    async getTransaction(txId) {
        return this.getJson(`${this.basePath}/tx/${txId}`);
    }
    async getTransactionStatus(txId) {
        return this.getJson(`${this.basePath}/tx/${txId}/status`);
    }
    async getTransactionHex(txId) {
        return this.getText(`${this.basePath}/tx/${txId}/hex`);
    }
    async getMerkleProof(txId) {
        const response = await this.getJson(`${this.basePath}/tx/${txId}/merkle-proof`);
        return {
            blockHeight: response.block_height,
            merkle: encodeEsploraMerkleProof(response.merkle),
            pos: response.pos,
        };
    }
    async getFeeEstimate(confirmationTarget) {
        const response = await this.getJson(`${this.basePath}/fee-estimates`);
        return response[confirmationTarget];
    }
    async getFeeEstimates() {
        return this.getJson(`${this.basePath}/fee-estimates`);
    }
    async getAddressUtxos(address, confirmed) {
        const response = await this.getJson(`${this.basePath}/address/${address}/utxo`);
        return response
            .filter((utxo) => (typeof confirmed !== 'undefined' ? confirmed === utxo.status.confirmed : true))
            .map((utxo) => {
            return {
                txid: utxo.txid,
                vout: utxo.vout,
                value: utxo.value,
                confirmed: utxo.status.confirmed,
                height: utxo.status.block_height,
            };
        });
    }
    async broadcastTx(txHex) {
        const res = await fetch(`${this.basePath}/tx`, {
            method: 'POST',
            body: txHex,
        });
        return await res.text();
    }
    async getBalance(address) {
        const response = await this.getJson(`${this.basePath}/address/${address}`);
        const confirmedBalance = response.chain_stats.funded_txo_sum - response.chain_stats.spent_txo_sum;
        const unconfirmedBalance = response.mempool_stats.funded_txo_sum - response.mempool_stats.spent_txo_sum;
        return {
            confirmed: confirmedBalance,
            unconfirmed: unconfirmedBalance,
            total: confirmedBalance + unconfirmedBalance,
        };
    }
    async getJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        return (await response.json());
    }
    async getText(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        return await response.text();
    }
}
exports.EsploraClient = EsploraClient;
//# sourceMappingURL=esplora.js.map