"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBitcoinTxInfo = getBitcoinTxInfo;
exports.getBitcoinTxProof = getBitcoinTxProof;
exports.getBitcoinHeaders = getBitcoinHeaders;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const utils_1 = require("./utils");
async function getBitcoinTxInfo(esploraClient, txId, forWitness) {
    const txHex = await esploraClient.getTransactionHex(txId);
    const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);
    const versionBuffer = Buffer.allocUnsafe(4);
    versionBuffer.writeInt32LE(tx.version);
    const locktimeBuffer = Buffer.allocUnsafe(4);
    locktimeBuffer.writeInt32LE(tx.locktime);
    return {
        version: versionBuffer.toString('hex'),
        inputVector: (0, utils_1.encodeRawInput)(tx).toString('hex'),
        outputVector: (0, utils_1.encodeRawOutput)(tx).toString('hex'),
        locktime: locktimeBuffer.toString('hex'),
        witnessVector: forWitness ? (0, utils_1.encodeRawWitness)(tx).toString('hex') : undefined,
    };
}
async function getBitcoinTxProof(esploraClient, txId, txProofDifficultyFactor) {
    const merkleProof = await esploraClient.getMerkleProof(txId);
    const bitcoinHeaders = await getBitcoinHeaders(esploraClient, merkleProof.blockHeight, txProofDifficultyFactor);
    return {
        merkleProof: merkleProof.merkle,
        txIndexInBlock: merkleProof.pos,
        bitcoinHeaders: bitcoinHeaders,
    };
}
async function getBitcoinHeaders(esploraClient, startHeight, numBlocks) {
    const range = (start, end) => Array.from({ length: end - start }, (_element, index) => index + start);
    const blockHeights = range(startHeight, startHeight + numBlocks);
    const bitcoinHeaders = await Promise.all(blockHeights.map(async (height) => {
        const hash = await esploraClient.getBlockHash(height);
        return esploraClient.getBlockHeader(hash);
    }));
    return bitcoinHeaders.join('');
}
//# sourceMappingURL=relay.js.map