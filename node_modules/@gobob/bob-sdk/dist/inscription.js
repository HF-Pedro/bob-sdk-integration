"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inscription = exports.MAX_CHUNK_SIZE = exports.PROTOCOL_ID = void 0;
exports.chunkContent = chunkContent;
exports.parseInscriptions = parseInscriptions;
exports.getTxInscriptions = getTxInscriptions;
exports.getInscriptionFromId = getInscriptionFromId;
const bitcoin = __importStar(require("bitcoinjs-lib"));
const ordinal_api_1 = require("./ordinal-api");
const textEncoder = new TextEncoder();
const OP_INT_BASE = bitcoin.opcodes.OP_RESERVED;
const TAPROOT_ANNEX_PREFIX = 0x50;
exports.PROTOCOL_ID = Buffer.from('6f7264', 'hex');
const CONTENT_TYPE_TAG = bitcoin.opcodes.OP_1;
const CONTENT_ENCODING_TAG = bitcoin.opcodes.OP_9;
exports.MAX_CHUNK_SIZE = 520;
function chunkContent(data) {
    const body = [];
    let start = 0;
    while (start < data.length) {
        body.push(data.subarray(start, start + exports.MAX_CHUNK_SIZE));
        start += exports.MAX_CHUNK_SIZE;
    }
    return body;
}
function convertOpInt(value) {
    if (value >= bitcoin.opcodes.OP_1 && value <= bitcoin.opcodes.OP_16) {
        return value - OP_INT_BASE;
    }
    return value;
}
class Inscription {
    constructor(tags, body) {
        this.tags = tags ?? new Map();
        this.body = body;
    }
    getContentType() {
        const data = this.tags[CONTENT_TYPE_TAG];
        if (Buffer.isBuffer(data)) {
            return data.toString('utf-8');
        }
        return null;
    }
    getContentEncoding() {
        const data = this.tags[CONTENT_ENCODING_TAG];
        if (Buffer.isBuffer(data)) {
            return data.toString('utf-8');
        }
        return null;
    }
    setContentType(contentType) {
        this.tags[CONTENT_TYPE_TAG] = Buffer.from(textEncoder.encode(contentType));
    }
    setContentEncoding(contentEncoding) {
        this.tags[CONTENT_ENCODING_TAG] = Buffer.from(textEncoder.encode(contentEncoding));
    }
    getTags() {
        const tags = this.tags;
        return Object.keys(this.tags).map(function (key) {
            return [convertOpInt(Number(key)), tags[key]];
        });
    }
    toScript(xOnlyPublicKey) {
        return [
            xOnlyPublicKey,
            bitcoin.opcodes.OP_CHECKSIG,
            bitcoin.opcodes.OP_0,
            bitcoin.opcodes.OP_IF,
            exports.PROTOCOL_ID,
            ...this.getTags()
                .map(([key, value]) => [1, key, value])
                .flat(),
            bitcoin.opcodes.OP_0,
            ...chunkContent(this.body),
            bitcoin.opcodes.OP_ENDIF,
        ];
    }
}
exports.Inscription = Inscription;
(function (Inscription) {
    function createTextInscription(text) {
        return Inscription.createInscription('text/plain;charset=utf-8', Buffer.from(textEncoder.encode(text)));
    }
    Inscription.createTextInscription = createTextInscription;
    function createInscription(contentType, content) {
        const inscription = new Inscription();
        inscription.setContentType(contentType);
        inscription.body = content;
        return inscription;
    }
    Inscription.createInscription = createInscription;
})(Inscription || (exports.Inscription = Inscription = {}));
function getTapscript(witness) {
    const len = witness.length;
    const last = witness[len - 1];
    if (typeof last === 'undefined') {
        return null;
    }
    let scriptPosFromLast = 2;
    if (len >= 2 && last[0] == TAPROOT_ANNEX_PREFIX) {
        scriptPosFromLast = 3;
    }
    if (typeof witness[len - scriptPosFromLast] === 'undefined') {
        return null;
    }
    return bitcoin.script.decompile(witness[len - scriptPosFromLast]);
}
function parseInscriptions(tx) {
    const inscriptions = [];
    for (const txInput of tx.ins) {
        const tapscript = getTapscript(txInput.witness);
        if (tapscript == null) {
            continue;
        }
        const chunks = tapscript.values();
        for (let chunk = chunks.next(); !chunk.done; chunk = chunks.next()) {
            if (chunk.value != bitcoin.opcodes.OP_FALSE) {
                continue;
            }
            if (chunks.next().value != bitcoin.opcodes.OP_IF) {
                continue;
            }
            const data = chunks.next().value;
            if (!Buffer.isBuffer(data) && !data.equals(exports.PROTOCOL_ID)) {
                continue;
            }
            const tags = new Map();
            const body = [];
            let isBody = false;
            for (let chunk = chunks.next(); !chunk.done; chunk = chunks.next()) {
                if (chunk.value == bitcoin.opcodes.OP_ENDIF) {
                    inscriptions.push(new Inscription(tags, Buffer.concat(body)));
                    break;
                }
                else if (chunk.value == bitcoin.opcodes.OP_0) {
                    isBody = true;
                    continue;
                }
                if (!isBody) {
                    const data = chunks.next().value;
                    if (typeof chunk.value == 'number' && Buffer.isBuffer(data)) {
                        tags[chunk.value] = data;
                    }
                }
                else if (Buffer.isBuffer(chunk.value)) {
                    body.push(chunk.value);
                }
            }
        }
    }
    return inscriptions;
}
async function getTxInscriptions(esploraClient, txid) {
    const txHex = await esploraClient.getTransactionHex(txid);
    const tx = bitcoin.Transaction.fromHex(txHex);
    return parseInscriptions(tx);
}
async function getInscriptionFromId(esploraClient, inscriptionId) {
    const { txid, index } = ordinal_api_1.InscriptionId.fromString(inscriptionId);
    const inscriptions = await getTxInscriptions(esploraClient, txid);
    return inscriptions[index];
}
//# sourceMappingURL=inscription.js.map