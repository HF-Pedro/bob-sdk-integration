"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBtcNetwork = void 0;
exports.createBitcoinPsbt = createBitcoinPsbt;
exports.getInputFromUtxoAndTx = getInputFromUtxoAndTx;
exports.estimateTxFee = estimateTxFee;
exports.getBalance = getBalance;
const btc_signer_1 = require("@scure/btc-signer");
const base_1 = require("@scure/base");
const bitcoin_address_validation_1 = require("bitcoin-address-validation");
const esplora_1 = require("../esplora");
const ordinal_api_1 = require("../ordinal-api");
const bitcoinNetworks = {
    mainnet: btc_signer_1.NETWORK,
    testnet: btc_signer_1.TEST_NETWORK,
};
const getBtcNetwork = (name) => {
    return bitcoinNetworks[name];
};
exports.getBtcNetwork = getBtcNetwork;
async function createBitcoinPsbt(fromAddress, toAddress, amount, publicKey, opReturnData, feeRate, confirmationTarget = 3) {
    const addressInfo = (0, bitcoin_address_validation_1.getAddressInfo)(fromAddress);
    const utxoSelectionStrategy = 'default';
    if (addressInfo.network === 'regtest') {
        throw new Error('Bitcoin regtest not supported');
    }
    if (addressInfo.type === bitcoin_address_validation_1.AddressType.p2sh ||
        addressInfo.type === bitcoin_address_validation_1.AddressType.p2wsh ||
        addressInfo.type === bitcoin_address_validation_1.AddressType.p2tr) {
        if (!publicKey) {
            throw new Error('Public key is required to spend from the selected address type');
        }
    }
    const esploraClient = new esplora_1.EsploraClient(addressInfo.network);
    const ordinalsClient = new ordinal_api_1.OrdinalsClient(addressInfo.network);
    let confirmedUtxos = [];
    let outputsFromAddress = [];
    [confirmedUtxos, feeRate, outputsFromAddress] = await Promise.all([
        esploraClient.getAddressUtxos(fromAddress),
        feeRate === undefined ? esploraClient.getFeeEstimate(confirmationTarget) : feeRate,
        ordinalsClient.getOutputsFromAddress(fromAddress, 'cardinal'),
    ]);
    if (confirmedUtxos.length === 0) {
        throw new Error('No confirmed UTXOs');
    }
    const outpointsSet = new Set(outputsFromAddress.map((output) => output.outpoint));
    const possibleInputs = [];
    await Promise.all(confirmedUtxos.map(async (utxo) => {
        const hex = await esploraClient.getTransactionHex(utxo.txid);
        const transaction = btc_signer_1.Transaction.fromRaw(Buffer.from(hex, 'hex'), { allowUnknownOutputs: true });
        const input = getInputFromUtxoAndTx(addressInfo.network, utxo, transaction, addressInfo.type, publicKey);
        if (outpointsSet.has(ordinal_api_1.OutPoint.toString(utxo)))
            possibleInputs.push(input);
    }));
    const outputs = [
        {
            address: toAddress,
            amount: BigInt(amount),
        },
    ];
    if (opReturnData) {
        if (opReturnData.startsWith('0x')) {
            opReturnData = opReturnData.slice(2);
        }
        outputs.push({
            script: btc_signer_1.Script.encode(['RETURN', base_1.hex.decode(opReturnData)]),
            amount: BigInt(0),
        });
    }
    const transaction = (0, btc_signer_1.selectUTXO)(possibleInputs, outputs, utxoSelectionStrategy, {
        changeAddress: fromAddress,
        feePerByte: BigInt(Math.ceil(feeRate)),
        bip69: true,
        createTx: true,
        network: (0, exports.getBtcNetwork)(addressInfo.network),
        allowUnknownOutputs: true,
        allowLegacyWitnessUtxo: true,
        dust: BigInt(546),
    });
    if (!transaction || !transaction.tx) {
        console.debug('confirmedUtxos', confirmedUtxos);
        console.debug('outputsFromAddress', outputsFromAddress);
        console.debug(`fromAddress: ${fromAddress}, toAddress: ${toAddress}, amount: ${amount}`);
        console.debug(`publicKey: ${publicKey}, opReturnData: ${opReturnData}`);
        console.debug(`feeRate: ${feeRate}, confirmationTarget: ${confirmationTarget}`);
        throw new Error('Failed to create transaction. Do you have enough funds?');
    }
    return base_1.base64.encode(transaction.tx.toPSBT(0));
}
function getInputFromUtxoAndTx(network, utxo, transaction, addressType, publicKey) {
    const output = transaction.getOutput(utxo.vout);
    let redeemScript = {};
    if (addressType === bitcoin_address_validation_1.AddressType.p2sh) {
        if (!publicKey) {
            throw new Error('Bitcoin P2SH not supported without public key');
        }
        const inner = (0, btc_signer_1.p2wpkh)(Buffer.from(publicKey, 'hex'), (0, exports.getBtcNetwork)(network));
        redeemScript = (0, btc_signer_1.p2sh)(inner);
    }
    else if (addressType === bitcoin_address_validation_1.AddressType.p2tr) {
        const xOnlyPublicKey = Buffer.from(publicKey, 'hex').subarray(1, 33);
        redeemScript = (0, btc_signer_1.p2tr)(xOnlyPublicKey);
    }
    const scriptMixin = {
        ...redeemScript,
    };
    const nonWitnessUtxo = {
        nonWitnessUtxo: Buffer.from(transaction.hex, 'hex'),
    };
    const witnessUtxo = {
        witnessUtxo: {
            script: output.script,
            amount: output.amount,
        },
    };
    const witnessMixin = transaction.hasWitnesses ? { ...witnessUtxo, ...nonWitnessUtxo } : nonWitnessUtxo;
    const input = {
        txid: utxo.txid,
        index: utxo.vout,
        ...scriptMixin,
        ...witnessMixin,
    };
    return input;
}
async function estimateTxFee(fromAddress, amount, publicKey, opReturnData, feeRate, confirmationTarget = 3) {
    const addressInfo = (0, bitcoin_address_validation_1.getAddressInfo)(fromAddress);
    if (addressInfo.network === 'regtest') {
        throw new Error('Bitcoin regtest not supported');
    }
    if (addressInfo.type === bitcoin_address_validation_1.AddressType.p2sh ||
        addressInfo.type === bitcoin_address_validation_1.AddressType.p2wsh ||
        addressInfo.type === bitcoin_address_validation_1.AddressType.p2tr) {
        if (!publicKey) {
            throw new Error('Public key is required to spend from the selected address type');
        }
    }
    const toAddress = fromAddress;
    const esploraClient = new esplora_1.EsploraClient(addressInfo.network);
    const ordinalsClient = new ordinal_api_1.OrdinalsClient(addressInfo.network);
    let confirmedUtxos = [];
    let outputsFromAddress = [];
    [confirmedUtxos, feeRate, outputsFromAddress] = await Promise.all([
        esploraClient.getAddressUtxos(fromAddress),
        feeRate === undefined ? esploraClient.getFeeEstimate(confirmationTarget) : feeRate,
        ordinalsClient.getOutputsFromAddress(fromAddress, 'cardinal'),
    ]);
    if (confirmedUtxos.length === 0) {
        throw new Error('No confirmed UTXOs');
    }
    const outpointsSet = new Set(outputsFromAddress.map((output) => output.outpoint));
    const possibleInputs = [];
    await Promise.all(confirmedUtxos.map(async (utxo) => {
        const hex = await esploraClient.getTransactionHex(utxo.txid);
        const transaction = btc_signer_1.Transaction.fromRaw(Buffer.from(hex, 'hex'), { allowUnknownOutputs: true });
        const input = getInputFromUtxoAndTx(addressInfo.network, utxo, transaction, addressInfo.type, publicKey);
        if (outpointsSet.has(ordinal_api_1.OutPoint.toString(utxo)))
            possibleInputs.push(input);
    }));
    const outputs = [
        {
            address: toAddress,
            amount: BigInt(amount ? amount : 0),
        },
    ];
    if (opReturnData) {
        if (opReturnData.toLowerCase().startsWith('0x')) {
            opReturnData = opReturnData.slice(2);
        }
        outputs.push({
            script: btc_signer_1.Script.encode(['RETURN', base_1.hex.decode(opReturnData)]),
            amount: BigInt(0),
        });
    }
    let utxoSelectionStrategy = 'default';
    if (amount === undefined) {
        utxoSelectionStrategy = 'all';
    }
    const transaction = (0, btc_signer_1.selectUTXO)(possibleInputs, outputs, utxoSelectionStrategy, {
        changeAddress: fromAddress,
        feePerByte: BigInt(Math.ceil(feeRate)),
        bip69: true,
        createTx: true,
        network: (0, exports.getBtcNetwork)(addressInfo.network),
        allowUnknownOutputs: true,
        allowLegacyWitnessUtxo: true,
        dust: BigInt(546),
    });
    if (!transaction || !transaction.tx) {
        console.debug('confirmedUtxos', confirmedUtxos);
        console.debug('outputsFromAddress', outputsFromAddress);
        console.debug(`fromAddress: ${fromAddress}, amount: ${amount}`);
        console.debug(`publicKey: ${publicKey}, opReturnData: ${opReturnData}`);
        console.debug(`feeRate: ${feeRate}, confirmationTarget: ${confirmationTarget}`);
        throw new Error('Failed to create transaction. Do you have enough funds?');
    }
    return transaction.fee;
}
async function getBalance(address) {
    if (!address) {
        return { confirmed: BigInt(0), unconfirmed: BigInt(0), total: BigInt(0) };
    }
    const addressInfo = (0, bitcoin_address_validation_1.getAddressInfo)(address);
    const esploraClient = new esplora_1.EsploraClient(addressInfo.network);
    const ordinalsClient = new ordinal_api_1.OrdinalsClient(addressInfo.network);
    const [outputs, cardinalOutputs] = await Promise.all([
        esploraClient.getAddressUtxos(address),
        ordinalsClient.getOutputsFromAddress(address, 'cardinal'),
    ]);
    const cardinalOutputsSet = new Set(cardinalOutputs.map((output) => output.outpoint));
    const total = outputs.reduce((acc, output) => {
        if (cardinalOutputsSet.has(ordinal_api_1.OutPoint.toString(output))) {
            return acc + output.value;
        }
        return acc;
    }, 0);
    const confirmed = outputs.reduce((acc, output) => {
        if (cardinalOutputsSet.has(ordinal_api_1.OutPoint.toString(output)) && output.confirmed) {
            return acc + output.value;
        }
        return acc;
    }, 0);
    return {
        confirmed: BigInt(confirmed),
        unconfirmed: BigInt(total - confirmed),
        total: BigInt(total),
    };
}
//# sourceMappingURL=utxo.js.map